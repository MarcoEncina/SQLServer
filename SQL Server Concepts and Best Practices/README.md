SQL Server Concepts and Best Practices
===================


**MAX vs Top 1 - which one is better?**
----------

When **there is a clustered index** on the table and the column to be queried, both the MAX() operator and the query SELECT TOP 1 will have almost identical performance.

When **there is no clustered index (Heap)**  on the table and the column to be queried, the MAX() operator offers the better performance.So, as we still have a whole bunch of Heap tables, consider using MAX rather than SELECT TOP 1.


**CTE vs #temp table**
---------
CTEs...

	* Are unindexable (but can use existing indexes on referenced objects)
	* Cannot have constraints
	* Are essentially disposable VIEWs
	* Persist only until the next query is run
	* Can be recursive
	* Do not have dedicated stats (rely on stats on the underlying objects)

Temp Tables...

	* Are real materialized tables that exist in tempdb
	* Can be indexed
	* Can have constraints
	* Persist for the life of the current CONNECTION
	* Can be referenced by other queries or subprocedures
	* Have dedicated stats generated by the engine

As far as when to use each, they have very different use cases. If you will have a very large result set, or need to refer to it more than once, put it in a #temp table. If it needs to be recursive, is disposable, or is just to simplify something logically, a CTE is preferred.
Also, a CTE should never be used for performance. You will almost never speed things up by using a CTE, because, again, it's just a disposable view. You can do some neat things with them but speeding up a query isn't really one of them.

**When to use char/varchar/nchar/nvarchar?**
----------
   - **nchar** and **nvarchar** can store **Unicode** characters.
   - **char** and **varchar** cannot store **Unicode** characters.
   - **char** and **nchar** are **fixed-length** which will **reserve storage** space for number of characters you specify even if you don't use up all that space.
   - **varchar** and **nvarchar** are **variable-length** which will only use up spaces for the characters you store. It **will not reserve storage like  char  or  nchar**. nchar and nvarchar will take up twice as much storage space, so it may be wise to use them only if you need Unicode support.

It is worth highlighting the importance to keep your code (variables) using the same data type definition as the column definition. Mismatch data types will probably result in Non-Sargable queries.

**Using the same column name in different tables but with different data types**
----------

Probably anybody will assume that columns with the same name in different tables have the same data type. As a result, they wonâ€™t verify data types. Different types is an accident waiting to happen.

Check that before creating a new column with the same name:
```SQL
SELECT sh.name+'.'+o.name AS ObjectName,
s.name as ColumnName,
CASE WHEN t.name IN ('char','varchar') THEN t.name+'('+CASE WHEN s.max_length<0 then 'MAX' ELSE CONVERT(varchar(10),s.max_length) END+')'
WHEN t.name IN ('nvarchar','nchar') THEN t.name+'('+CASE WHEN s.max_length<0 then 'MAX' ELSE CONVERT(varchar(10),s.max_length/2) END+')'
WHEN t.name IN ('numeric') THEN t.name+'('+CONVERT(varchar(10),s.precision)+','+CONVERT(varchar(10),s.scale)+')'
ELSE t.name END AS DataType
,CASE WHEN s.is_nullable=1 THEN 'NULL' ELSE 'NOT NULL' END AS Nullable     
FROM sys.columns s
INNER JOIN sys.types t ON s.system_type_id=t.user_type_id and t.is_user_defined=0
INNER JOIN sys.objects o ON s.object_id=o.object_id
INNER JOIN sys.schemas sh on o.schema_id=sh.schema_id
WHERE O.name IN (select table_name from information_schema.tables)
--AND s.name = 'NewColumn'
ORDER BY sh.name+'.'+o.name,s.column_id
```

**Use =instead of AS for column aliases**
----------

There is no performance difference between both of them. But, which is easier to ready? 
Remember, the T-SQL code you write is not consumed solely by you, and you know that some queries will be a lot bigger than that. 
![Text](http://bertrandaaron.files.wordpress.com/2012/01/bh_as_procs.png)



